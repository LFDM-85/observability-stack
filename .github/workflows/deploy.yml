name: Deploy to Monitoring Server

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:  # Permite execuÃ§Ã£o manual
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  DEPLOY_USER: root
  DEPLOY_HOST: 10.10.1.159
  DEPLOY_PATH: /root/observability-stack

jobs:
  deploy:
    name: Deploy Observability Stack
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Verify SSH key secret exists
        run: |
          if [ -z "${{ secrets.DEPLOY_SSH_KEY }}" ]; then
            echo "âŒ ERROR: DEPLOY_SSH_KEY secret not configured"
            echo ""
            echo "Please configure the secret:"
            echo "1. Run: bash scripts/setup_cicd.sh"
            echo "2. Go to: Settings â†’ Secrets â†’ Actions"
            echo "3. Add secret: DEPLOY_SSH_KEY"
            echo ""
            exit 1
          fi
          echo "âœ… SSH key secret found"
        
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
      - name: Add server to known hosts
        run: |
          ssh-keyscan -H ${{ env.DEPLOY_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          
      - name: Test SSH connection
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=10 \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} \
            'echo "âœ… SSH connection successful"'
            
      - name: Create deployment package
        run: |
          echo "Creating deployment package..."
          tar --exclude='.git' \
              --exclude='*_data' \
              --exclude='*.tar.gz' \
              --exclude='.github' \
              --exclude='__pycache__' \
              -czf observability-stack.tar.gz .
          ls -lh observability-stack.tar.gz
          
      - name: Upload package to server
        run: |
          echo "Uploading package to server..."
          scp -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            observability-stack.tar.gz \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }}:/tmp/
          echo "âœ… Package uploaded"
            
      - name: Backup current deployment
        run: |
          echo "Creating backup of current deployment..."
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
            if [ -d "${{ env.DEPLOY_PATH }}" ]; then
              BACKUP_NAME="observability-stack-backup-$(date +%Y%m%d-%H%M%S)"
              cp -r ${{ env.DEPLOY_PATH }} /root/$BACKUP_NAME
              echo "âœ… Backup created: /root/$BACKUP_NAME"
            else
              echo "â„¹ï¸  No existing deployment to backup"
            fi
          ENDSSH
          
      - name: Extract and deploy
        run: |
          echo "Extracting deployment package..."
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
            set -e
            
            # Criar diretÃ³rio se nÃ£o existir
            mkdir -p ${{ env.DEPLOY_PATH }}
            
            # Extrair novo cÃ³digo
            cd ${{ env.DEPLOY_PATH }}
            tar -xzf /tmp/observability-stack.tar.gz
            
            # Dar permissÃµes de execuÃ§Ã£o
            chmod +x setup.sh diagnose.sh scripts/*.sh 2>/dev/null || true
            
            # Limpar ficheiro temporÃ¡rio
            rm /tmp/observability-stack.tar.gz
            
            echo "âœ… Deployment extracted successfully"
          ENDSSH
          
      - name: Verify environment files
        run: |
          echo "Verifying environment configuration..."
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
            cd ${{ env.DEPLOY_PATH }}
            
            # Verificar se .env existe
            if [ ! -f .env ]; then
              echo "âš ï¸  WARNING: .env file not found"
              if [ -f .env.example ]; then
                echo "Creating .env from example..."
                cp .env.example .env
                echo "âŒ CRITICAL: Configure .env with webhooks before starting stack!"
                echo "Run: ssh root@${{ env.DEPLOY_HOST }} 'nano ${{ env.DEPLOY_PATH }}/.env'"
                exit 1
              else
                echo "âŒ CRITICAL: .env.example not found!"
                exit 1
              fi
            fi
            
            # Verificar se hosts.txt existe
            if [ ! -f hosts.txt ]; then
              echo "âš ï¸  WARNING: hosts.txt not found"
              if [ -f hosts.txt.example ]; then
                echo "Creating hosts.txt from example..."
                cp hosts.txt.example hosts.txt
                echo "âŒ CRITICAL: Configure hosts.txt before deploying monitors!"
                echo "Run: ssh root@${{ env.DEPLOY_HOST }} 'nano ${{ env.DEPLOY_PATH }}/hosts.txt'"
                exit 1
              else
                echo "âŒ CRITICAL: hosts.txt.example not found!"
                exit 1
              fi
            fi
            
            echo "âœ… Environment files verified"
          ENDSSH
          
      - name: Restart Docker stack
        run: |
          echo "Restarting Docker stack..."
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
            cd ${{ env.DEPLOY_PATH }}
            
            # Verificar se Docker estÃ¡ instalado
            if ! command -v docker &> /dev/null; then
              echo "âŒ Docker not installed on target server"
              echo "Install with: apt install -y docker.io docker-compose"
              exit 1
            fi
            
            # Parar stack atual
            echo "Stopping current stack..."
            docker compose down 2>/dev/null || docker-compose down 2>/dev/null || true
            
            # Pull de novas imagens
            echo "Pulling latest images..."
            docker compose pull 2>/dev/null || docker-compose pull 2>/dev/null
            
            # Iniciar stack
            echo "Starting stack..."
            docker compose up -d 2>/dev/null || docker-compose up -d 2>/dev/null
            
            # Aguardar containers iniciarem
            echo "Waiting for containers to start..."
            sleep 15
            
            # Verificar status
            echo ""
            echo "Container status:"
            docker compose ps 2>/dev/null || docker-compose ps 2>/dev/null
          ENDSSH
          
      - name: Health check
        run: |
          echo "Running health check..."
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
            cd ${{ env.DEPLOY_PATH }}
            
            # Verificar se Python estÃ¡ disponÃ­vel
            if command -v python3 &> /dev/null; then
              echo "Running automated health check..."
              python3 scripts/check_health.py 2>/dev/null || echo "âš ï¸  Health check script failed"
            else
              echo "âš ï¸  Python3 not available, skipping automated health check"
              echo ""
              echo "Manual verification:"
              docker compose ps 2>/dev/null || docker-compose ps 2>/dev/null
            fi
          ENDSSH
          
      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          
      - name: Deployment summary
        if: success()
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Deployment successful!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "Services available at:"
          echo "  ğŸ¨ Grafana:      http://${{ env.DEPLOY_HOST }}:3000"
          echo "  ğŸ“Š Prometheus:   http://${{ env.DEPLOY_HOST }}:9990"
          echo "  ğŸ”” Alertmanager: http://${{ env.DEPLOY_HOST }}:9093"
          echo ""
          echo "Next steps:"
          echo "  1. Access Grafana (admin/admin)"
          echo "  2. Check Prometheus targets: http://${{ env.DEPLOY_HOST }}:9990/targets"
          echo "  3. View dashboards"
          echo ""
          
      - name: Deployment failed
        if: failure()
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âŒ Deployment failed!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "Troubleshooting:"
          echo "  1. Check the logs above for specific errors"
          echo "  2. Verify SSH access: ssh root@${{ env.DEPLOY_HOST }}"
          echo "  3. Check server logs: ssh root@${{ env.DEPLOY_HOST }} 'cd ${{ env.DEPLOY_PATH }} && docker compose logs'"
          echo ""
          echo "Rollback if needed:"
          echo "  ssh root@${{ env.DEPLOY_HOST }}"
          echo "  cd /root"
          echo "  ls -d observability-stack-backup-*"
          echo "  mv observability-stack-backup-YYYYMMDD-HHMMSS observability-stack"
          echo ""
